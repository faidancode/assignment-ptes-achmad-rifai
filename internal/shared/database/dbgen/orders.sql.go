// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: orders.sql

package dbgen

import (
	"context"
	"encoding/json"
	"time"

	"github.com/shopspring/decimal"
)

const createOrder = `-- name: CreateOrder :exec
INSERT INTO
    orders (
        id,
        customer_id,
        total_quantity,
        total_price,
        created_at
    )
VALUES
    (?, ?, ?, ?, ?)
`

type CreateOrderParams struct {
	ID            string          `json:"id"`
	CustomerID    string          `json:"customer_id"`
	TotalQuantity int32           `json:"total_quantity"`
	TotalPrice    decimal.Decimal `json:"total_price"`
	CreatedAt     time.Time       `json:"created_at"`
}

// Sqlc Query
func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) error {
	_, err := q.exec(ctx, q.createOrderStmt, createOrder,
		arg.ID,
		arg.CustomerID,
		arg.TotalQuantity,
		arg.TotalPrice,
		arg.CreatedAt,
	)
	return err
}

const createOrderItem = `-- name: CreateOrderItem :exec
INSERT INTO
    order_items (id, order_id, product_id, quantity, unit_price)
VALUES
    (?, ?, ?, ?, ?)
`

type CreateOrderItemParams struct {
	ID        string          `json:"id"`
	OrderID   string          `json:"order_id"`
	ProductID string          `json:"product_id"`
	Quantity  int32           `json:"quantity"`
	UnitPrice decimal.Decimal `json:"unit_price"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) error {
	_, err := q.exec(ctx, q.createOrderItemStmt, createOrderItem,
		arg.ID,
		arg.OrderID,
		arg.ProductID,
		arg.Quantity,
		arg.UnitPrice,
	)
	return err
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM orders
WHERE
    id = ?
`

func (q *Queries) DeleteOrder(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteOrderStmt, deleteOrder, id)
	return err
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT
    o.id,
    o.total_quantity,
    o.total_price,
    o.created_at,
    o.customer_id,
    c.name AS customer_name,
    c.email AS customer_email,
    CAST(
        JSON_ARRAYAGG(
            JSON_OBJECT(
                'id',
                oi.id,
                'product_id',
                p.id,
                'product_name',
                p.name,
                'quantity',
                oi.quantity,
                'unit_price',
                oi.unit_price
            )
        ) AS JSON
    ) AS items
FROM
    orders o
    JOIN customers c ON o.customer_id = c.id
    JOIN order_items oi ON o.id = oi.order_id
    JOIN products p ON oi.product_id = p.id
    JOIN categories cat ON p.category_id = cat.id
WHERE
    o.id = ?
GROUP BY
    o.id,
    c.id
LIMIT
    1
`

type GetOrderByIDRow struct {
	ID            string          `json:"id"`
	TotalQuantity int32           `json:"total_quantity"`
	TotalPrice    decimal.Decimal `json:"total_price"`
	CreatedAt     time.Time       `json:"created_at"`
	CustomerID    string          `json:"customer_id"`
	CustomerName  string          `json:"customer_name"`
	CustomerEmail string          `json:"customer_email"`
	Items         json.RawMessage `json:"items"`
}

func (q *Queries) GetOrderByID(ctx context.Context, id string) (GetOrderByIDRow, error) {
	row := q.queryRow(ctx, q.getOrderByIDStmt, getOrderByID, id)
	var i GetOrderByIDRow
	err := row.Scan(
		&i.ID,
		&i.TotalQuantity,
		&i.TotalPrice,
		&i.CreatedAt,
		&i.CustomerID,
		&i.CustomerName,
		&i.CustomerEmail,
		&i.Items,
	)
	return i, err
}

const getOrderItemsByOrderID = `-- name: GetOrderItemsByOrderID :many
SELECT
    id,
    order_id,
    product_id,
    quantity,
    unit_price
FROM
    order_items
WHERE
    order_id = ?
`

func (q *Queries) GetOrderItemsByOrderID(ctx context.Context, orderID string) ([]OrderItem, error) {
	rows, err := q.query(ctx, q.getOrderItemsByOrderIDStmt, getOrderItemsByOrderID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderItem
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.Quantity,
			&i.UnitPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrders = `-- name: GetOrders :many
SELECT
    o.id,
    o.total_quantity,
    o.total_price,
    o.created_at,
    o.customer_id,
    c.name AS customer_name,
    c.email AS customer_email,
    CAST(
        JSON_ARRAYAGG(
            JSON_OBJECT(
                'id',
                oi.id,
                'product_id',
                p.id,
                'product_name',
                p.name,
                'quantity',
                oi.quantity,
                'unit_price',
                oi.unit_price
            )
        ) AS JSON
    ) AS items
FROM
    orders o
    JOIN customers c ON o.customer_id = c.id
    JOIN order_items oi ON o.id = oi.order_id
    JOIN products p ON oi.product_id = p.id
GROUP BY
    o.id,
    c.id
ORDER BY
    o.created_at DESC
LIMIT
    ?
OFFSET
    ?
`

type GetOrdersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetOrdersRow struct {
	ID            string          `json:"id"`
	TotalQuantity int32           `json:"total_quantity"`
	TotalPrice    decimal.Decimal `json:"total_price"`
	CreatedAt     time.Time       `json:"created_at"`
	CustomerID    string          `json:"customer_id"`
	CustomerName  string          `json:"customer_name"`
	CustomerEmail string          `json:"customer_email"`
	Items         json.RawMessage `json:"items"`
}

func (q *Queries) GetOrders(ctx context.Context, arg GetOrdersParams) ([]GetOrdersRow, error) {
	rows, err := q.query(ctx, q.getOrdersStmt, getOrders, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrdersRow
	for rows.Next() {
		var i GetOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.TotalQuantity,
			&i.TotalPrice,
			&i.CreatedAt,
			&i.CustomerID,
			&i.CustomerName,
			&i.CustomerEmail,
			&i.Items,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
